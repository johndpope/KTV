//
// Created by Alexander Babaev on 13.02.16.
// Copyright (c) 2016 LonelyBytes. All rights reserved.
//

import Foundation

public class KTVGenerator {
    private struct GeneratedProperty {
        let name:String
        let type:String
        let genericType:String

        var attributes:[String:String] = [:]
    }

    private struct ClassParameters {
        var isStruct:Bool = false
        var isPublic:Bool = false
        var isPrivate:Bool = false
        var annotations:[String:String] = [:]
    }

    private let _rootPathToSearchForClasses:String
    private let _rootPathToSaveGeneratedTo:String

    private var _generatedExtensions:[String:String] = [:]

    init(pathToSearchForClasses:String, pathToSaveGeneratedTo:String) {
        _rootPathToSearchForClasses = pathToSearchForClasses
        _rootPathToSaveGeneratedTo = pathToSaveGeneratedTo
    }

    public func process() throws {
        try processFiles(try findFilesThatNeedGeneration())
        try saveGeneratedExtensions()
    }

    private func saveGeneratedExtensions() throws {
        let path = (_rootPathToSaveGeneratedTo as NSString).stringByAppendingPathComponent("KTVModelExtensions.swift")

        let generatedFile = _generatedExtensions.values.reduce(
                "// AUTOGENERATED FILE\n" +
                "// Do not edit manually please\n" +
                "\n" +
                "import Foundation\n\n") { currentString, next in
            if currentString.isEmpty {
                return next
            } else {
                return currentString + "\n\n" + next
            }
        }

        try (generatedFile as NSString).writeToFile(path, atomically:true, encoding:NSUTF8StringEncoding)
    }

    private func processFiles(classNames:[String]) throws {
        // 1. Составить список всех классов в файлах
        // 2. Для каждого класса составить список полей и их типов. Для этого:
        //    — использовать текст файла чтобы понять, где какое поле приватное или не может быть записано
        //    — да и для всего остального тоже. В крайнем случае можно еще использовать Mirror, но это потребует перекомпиляции и
        //      передачи классов куда-то в генератор
        for classFileName in classNames {
            try processFile(classFileName)
        }
    }

    private func processFile(classFileName:String) throws {
        print("Processing " + classFileName)

        let sourceKitFile = File(path:classFileName)
        let structure = Structure(file:sourceKitFile!).dictionary
        guard let structureWithDocs = SwiftDocs(file:sourceKitFile!, arguments:[classFileName])?.docsDictionary else {
//        guard let structure = SwiftDocs(file:sourceKitFile!, arguments:[classFileName])?.docsDictionary else {
            throw KTVGeneratorError.ErrorParsingFile
        }

        let fileStructure = toAnyObject(structure)
        let docStructure = toAnyObject(structureWithDocs)

        let (classes, classesParameters) = try findClasses(fileStructure, docs:docStructure)

        for (name, properties) in classes {
            if let classParameters = classesParameters[name] {
                var className = name
                var accessLevel = ""
                var isStruct = false
                if classParameters.isStruct {
                    className = className.stringByReplacingOccurrencesOfString("#struct", withString:"")
                    isStruct = true
                }

                if classParameters.isPublic {
                    className = className.stringByReplacingOccurrencesOfString("#public", withString: "")
                    accessLevel = "public "
                } else if classParameters.isPrivate {
                    className = className.stringByReplacingOccurrencesOfString("#private", withString:"")
                }

                var mapperFactoryClass = "KTVModelMapperFactory"
                if let customMapperFactory = classParameters.annotations["mapper"] {
                    mapperFactoryClass = customMapperFactory
                }

                let generatedParser = generateParserForClass(className, modelMapperFactoryClass:mapperFactoryClass, accessLevel:accessLevel, isStruct:isStruct, properties:properties)
                let generatedSerializer = try generateSerializerForClass(className, modelMapperFactoryClass:mapperFactoryClass, accessLevel:accessLevel, isStruct:isStruct, properties:properties)

                _generatedExtensions[name] = generatedParser + "\n" + generatedSerializer

                print("  Generated methods for " + className)
            }
        }
    }

    private func generateSerializerForClass(className:String, modelMapperFactoryClass:String, accessLevel:String, isStruct:Bool, properties:[GeneratedProperty]) throws -> String {
        var propertyGetters = ""

        for property in properties {
            let type = property.type.stringByReplacingOccurrencesOfString("?", withString: "")

            var mapperClass = "KTVModelMapper"

            let optionalForced = property.type.hasSuffix("?") ? "!" : ""

            var objectCustomMapper = ""

            switch type.lowercaseString {
                case "string":
                    mapperClass += "String"
                case "int":
                    mapperClass += "Int"
                case "double":
                    mapperClass += "Double"
                case "bool":
                    mapperClass += "Bool"
                case "nsdate":
                    mapperClass += "NSDate"
                case "uicolor":
                    mapperClass += "UIColor"
                case "[]":
                    mapperClass += "Array"
                case "[:]":
                    mapperClass += "Dictionary"
                case "cgrect":
                    mapperClass += "CGRect"
                case "cgsize":
                    mapperClass += "CGSize"
                case "cgpoint":
                    mapperClass += "CGPoint"
                case "uiedgeinsets":
                    mapperClass += "UIEdgeInsets"
                default:
                    objectCustomMapper = "KTVValue.object(\"\", try \(property.name)\(optionalForced).ktvObject())"
            }

            var ktvPropertyName = "mappers.ktvNameFor(\"\(property.name)\")"
            if let ktvName = property.attributes["ktv"] {
                ktvPropertyName = "\"\(ktvName)\""
            }

            if objectCustomMapper.isEmpty {
                propertyGetters += "        result.setProperty(name:\(ktvPropertyName), value:try mappers.mapper(\"\(mapperClass)\", propertyName:\(ktvPropertyName)).compose(\(property.name)))\n"
            } else {
                propertyGetters += "        result.setProperty(name:\(ktvPropertyName), value:object == nil ? KTVValue.nilValue : \(objectCustomMapper))\n"
            }
        }

        return
                "\nextension \(className): KTVSerializable {\n" +
                "    \(accessLevel)func ktvObject() throws -> KTVObject {\n" +
                "        let result = KTVObject()\n" +
                "\n" +
                "        let mappers = \(modelMapperFactoryClass)()\n" +
                "\n" +
                         propertyGetters +
                "\n" +
                "        return result\n" +
                "    }\n" +
                "}"
    }

    private func generateParserForClass(className:String, modelMapperFactoryClass:String, accessLevel:String, isStruct:Bool, properties:[GeneratedProperty]) -> String {
        let initializerFromDictionaryPrefix = isStruct ? "        self.init(" : "        self.init()"
        let initializerFromDictionarySuffix = isStruct ? ")\n" : "\n"
        var initializerFromDictionary = ""

        var localVariableInitializers = ""
        var localVariableSetters = ""
        var dictionaryBody = ""

        for property in properties {
            let type = property.type.stringByReplacingOccurrencesOfString("?", withString:"")

            var mapperType = ""
            let methodOptionalPart = property.type.hasSuffix("?") ? "Optional" : "NotOptional"
            let typeOptionalPart = property.type.hasSuffix("?") ? "?" : ""
            var parserForSubClassesAndMappers = ""

            var realPropertyType = "\(property.type)"

            var ktvPropertyName = "mappers.ktvNameFor(\"\(property.name)\")"
            if let ktvName = property.attributes["ktv"] {
                ktvPropertyName = "\"\(ktvName)\""
            }

            switch type.lowercaseString {
                case "string":
                    mapperType = "String"
                case "int":
                    mapperType = "Int"
                case "double":
                    mapperType = "Double"
                case "bool":
                    mapperType = "Bool"
                case "uicolor":
                    mapperType = "UIColor"
                case "nsdate":
                    mapperType = "NSDate"
                case "[]":
                    mapperType = "[\(property.genericType)]"
                    realPropertyType = "[\(property.genericType)]\(typeOptionalPart)"
                case "[:]":
                    mapperType = "[String:\(property.genericType)]"
                    realPropertyType = "[String:\(property.genericType)]\(typeOptionalPart)"
                case "cgrect":
                    mapperType = "CGRect"
                case "cgsize":
                    mapperType = "CGSize"
                case "cgpoint":
                    mapperType = "CGPoint"
                case "uiedgeinsets":
                    mapperType = "UIEdgeInsets"
                case "datemapper":
                    parserForSubClassesAndMappers = ""
                default:
                    //ToDo: тут нужно проверить, что тип — среди найденных классов, иначе он не распарсится
                    parserForSubClassesAndMappers += "        do {\n"
                    if !methodOptionalPart.isEmpty {
                        parserForSubClassesAndMappers += "            if let _\(property.name)_ = try KTVModelBasicMapper.getGeneralObject(name:\(ktvPropertyName), ktv:ktv) {\n"
                        parserForSubClassesAndMappers += "                _\(property.name) = \(type)(ktvLenient:_\(property.name)_)\n"
                        parserForSubClassesAndMappers += "            } else {\n"
                        parserForSubClassesAndMappers += "                _\(property.name) = nil\n"
                        parserForSubClassesAndMappers += "            } \n"
                    } else {
                        parserForSubClassesAndMappers += "            if let _\(property.name)_ = try KTVModelBasicMapper.getGeneralObject(name:\(ktvPropertyName), ktv:ktv) {\n"
                        parserForSubClassesAndMappers += "                _\(property.name) = \(type)(ktvLenient:_\(property.name)_)\n"
                        parserForSubClassesAndMappers += "            }\n"
                    }
                    parserForSubClassesAndMappers += "        } catch { errors[\"\(property.name)\"] = error }\n"
                    break
            }

            if isStruct {
                if !initializerFromDictionary.isEmpty {
                    initializerFromDictionary += ",\n"
                }
                initializerFromDictionary += "            \(property.name):values[\"\(property.name)\"] as! \(realPropertyType)"
            } else {
                initializerFromDictionary += "        \(property.name) = values[\"\(property.name)\"] as! \(realPropertyType)"
            }

            localVariableInitializers +=
                    "        var _\(property.name) = \(realPropertyType)()\n"

            dictionaryBody +=
                    "            \"\(property.name)\": _\(property.name),\n"

            if !parserForSubClassesAndMappers.isEmpty {
                localVariableSetters += parserForSubClassesAndMappers
            } else {
                localVariableSetters +=
                        "        do { _\(property.name) = try mappers" +
                                                                 ".mapper(\"\(mapperType)\", propertyName:\(ktvPropertyName))" +
                                                                 ".parse\(methodOptionalPart)Value(ktv[\"\(property.name)\"], defaultValue:_\(property.name))\n" +
                        "        } catch { errors[\"\(property.name)\"] = error }\n\n"
            }
        }

        let additionalMethodProperties = isStruct ? "" : "convenience "

        return
                "extension \(className): KTVParseable {\n" +
                "    \(accessLevel)\(additionalMethodProperties)init?(ktvStrict ktv:KTVObject) {\n" +
                "        let (values, errors) = \(className).parseKTV(ktv)\n" +
                "        KTVModelBasicMapper.printErrors(errors)\n" +
                "\n" +
                "        if !errors.isEmpty {\n" +
                "            return nil\n" +
                "        } else {\n" +
                "            self.init(values:values)\n" +
                "        }\n" +
                "    }\n" +
                "\n" +
                "    \(accessLevel)\(additionalMethodProperties)init(ktvLenient ktv:KTVObject) {\n" +
                "        let (values, errors) = \(className).parseKTV(ktv)\n" +
                "        KTVModelBasicMapper.printErrors(errors)\n" +
                "        self.init(values:values)\n" +
                "    }\n" +
                "\n" +
                "    private \(additionalMethodProperties)init(values:[String:AnyObject?]) {\n" +
                         initializerFromDictionaryPrefix + "\n" +
                         initializerFromDictionary +
                         initializerFromDictionarySuffix +
                "    }\n" +
                "\n" +
                "    static private func parseKTV(ktv:KTVObject) -> (values:[String:AnyObject?], errors:[String:ErrorType]) {\n" +
                "        var errors = [String:ErrorType]()\n" +
                "\n" +
                         localVariableInitializers +
                "\n" +
                "        let mappers = \(modelMapperFactoryClass)()\n" +
                "\n" +
                         localVariableSetters +
                "\n" +
                "        let values:[String:AnyObject?] = [\n" +
                             dictionaryBody +
                "        ]" +
                "\n" +
                "        return (values:values, errors:errors)\n" +
                "    }\n" +
                "}"
    }

    private func generateParserOldForClass(className:String, accessLevel:String, isStruct:Bool, properties:[GeneratedProperty]) -> String {
        var memberwiseInitializerArguments = ""
        var memberwiseInitializerBody = ""

        var propertySetters = ""

        for property in properties {
            let type = property.type.stringByReplacingOccurrencesOfString("?", withString:"")

            var methodTypePart = ""
            let methodOptionalPart = property.type.hasSuffix("?") ? "Optional" : ""
            var additionalParameters = ""
            var complexLines = ""

            var memberwiseInitializerPart = "\(property.name):\(property.type)"

            switch type.lowercaseString {
                case "string":
                    methodTypePart = "String"
                case "int":
                    methodTypePart = "Int"
                case "double":
                    methodTypePart = "Double"
                case "bool":
                    methodTypePart = "Bool"
                case "uicolor":
                    methodTypePart = "UIColor"
                case "[]":
                    methodTypePart = "Array"
                    additionalParameters = ", itemResolver:KTVValue.\(property.genericType.lowercaseString)Resolver"
                    memberwiseInitializerPart = "\(property.name):[\(property.genericType)]"
                case "[:]":
                    methodTypePart = "Dictionary"
                    additionalParameters = ", itemResolver:KTVValue.\(property.genericType.lowercaseString)Resolver"
                    memberwiseInitializerPart = "\(property.name):[String:\(property.genericType)]"
                case "cgrect":
                    methodTypePart = "CGRect"
                case "cgsize":
                    methodTypePart = "CGSize"
                case "cgpoint":
                    methodTypePart = "CGPoint"
                case "uiedgeinsets":
                    methodTypePart = "UIEdgeInsets"
                default:
                    //ToDo: тут нужно проверить, что тип — среди найденных классов, иначе он не распарсится
                    complexLines += "        do {\n"
                    if methodOptionalPart.isEmpty {
                        complexLines += "            if let \(property.name)_ = try \(className).getGeneralObject(name:\"\(property.name)\", ktv:ktv) {\n"
                        complexLines += "                \(property.name) = \(type)(ktvLenient:\(property.name)_)\n"
                        complexLines += "            } else {\n"
                        complexLines += "                \(property.name) = \(type)()\n"
                        complexLines += "            } \n"
                    } else {
                        complexLines += "            if let \(property.name)_ = try \(className).getGeneralObject(name:\"\(property.name)\", ktv:ktv) {\n"
                        complexLines += "                \(property.name) = \(type)(ktvLenient:\(property.name)_)\n"
                        complexLines += "            }\n"
                    }
                    complexLines += "        } catch { errors[\"\(property.name)\"] = error }\n"
            }

            if !complexLines.isEmpty {
                propertySetters += complexLines
            } else {
                propertySetters +=
                        "        do { " +
                        "\(property.name) = try \(className).get\(methodOptionalPart)\(methodTypePart)Value(name:\"\(property.name)\", ktv:ktv, defaultValue:\(property.name)\(additionalParameters)) } " +
                        "catch { errors[\"\(property.name)\"] = error }\n"
            }

            memberwiseInitializerArguments += memberwiseInitializerArguments.isEmpty ? memberwiseInitializerPart : ", " + memberwiseInitializerPart
            memberwiseInitializerBody += "        self.\(property.name) = \(property.name)\n"
        }

        let mutatingOrNot = isStruct ? "mutating " : ""
        let additionalMethodProperties = isStruct ? "" : "convenience "

        let memberwiseInitializer = !isStruct ? "" :
                "    \(additionalMethodProperties)init(" + memberwiseInitializerArguments + ") {\n" +
                "        self.init()\n\n" +
                         memberwiseInitializerBody +
                "    }\n\n"

        let classAddons = isStruct ? "" :
                "\n" +
                "    // for loading from ObjC\n" +
                "    static func parseKTVFromString(string:String) -> \(className) {\n" +
                "        return parseKTVFromString_(string)\n" +
                "    }\n"

        return
                "extension \(className): KTVParseable {\n" +
                     memberwiseInitializer +
                "    \(accessLevel)\(mutatingOrNot)func parseKTV(ktv:KTVObject) -> [String:ErrorType] {\n" +
                "        var errors = [String:ErrorType]()\n" +
                "\n" +
                         propertySetters +
                "\n" +
                "        return errors\n" +
                "    }\n" +
                     classAddons +
                "}"
    }

    private func isProperClass(structure:[String:AnyObject]) -> Bool {
        var result = false

        if let kind = structure[SwiftDocKey.Kind.rawValue] as? String {
            var isInheritedFromModelObject = false
            if let inheritedTypes = structure["key.inheritedtypes"] as? [[String:String]] {
                for dictionary in inheritedTypes {
                    if dictionary[SwiftDocKey.Name.rawValue] == "KTVModelObject" {
                        isInheritedFromModelObject = true
                        break
                    }
                }
            }

            //ToDo: проверить, видимо, еще и туплы
            result = isInheritedFromModelObject && (kind == SwiftDeclarationKind.Class.rawValue || kind == SwiftDeclarationKind.Struct.rawValue)
        }

        return result
    }

    private func findClasses(structure:[String:AnyObject], docs:[String:AnyObject]) throws -> (classes:[String:[GeneratedProperty]], classesParameters:[String:ClassParameters]) {
        var classes:[String:[GeneratedProperty]] = [:]
        var classesParameters:[String:ClassParameters] = [:]

        if isProperClass(structure) {
            if let name = structure[SwiftDocKey.Name.rawValue] as? String {
                classesParameters[name] = classParameters(docs)
                classes[name] = try findProperties(structure, docs:docs)
            }
        }

        if let substructure = structure[SwiftDocKey.Substructure.rawValue] as? [[String:AnyObject]],
                let subdocs = docs[SwiftDocKey.Substructure.rawValue] as? [[String:AnyObject]] {
            for (property, docProperty) in zip(substructure, subdocs) {
                if isProperClass(property) {
                    let (subClasses, subClassesParameters) = try findClasses(property, docs:docProperty)
                    for (subClassName, properties) in subClasses {
                        let subClassParameters = subClassesParameters[subClassName]

                        classesParameters[subClassName] = subClassParameters
                        classes[subClassName] = properties
                    }
                }
            }
        }

        return (classes:classes, classesParameters:classesParameters)
    }

    private func classParameters(structure:[String:AnyObject]) -> ClassParameters {
        var result = ClassParameters()

        result.annotations = extractAnnotations(structure)

        if let kind = structure[SwiftDocKey.Kind.rawValue] as? String where kind == SwiftDeclarationKind.Struct.rawValue {
            result.isStruct = true
        }

        if let accessibility = structure["key.accessibility"] as? String  {
            if accessibility == "source.lang.swift.accessibility.public" {
                result.isPublic = true
            } else if accessibility == "source.lang.swift.accessibility.private" {
                result.isPrivate = true
            }
        }

        return result
    }

    private func extractAnnotations(structure:[String:AnyObject]) -> [String:String] {
        if let comment = structure["key.doc.comment"] as? String where comment.containsString("@") {
            var annotations:[String:String] = [:]

            let annotationsRaw = comment.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()).componentsSeparatedByString("@")
            for annotationRaw in annotationsRaw {
                let annotationText = annotationRaw.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                if annotationText.isEmpty {
                    continue
                }

                if annotationText.containsString("=") {
                    let parts = annotationText.componentsSeparatedByString("=")
                    let name = parts[0].stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                    let value = parts[1].stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
                    annotations[name] = value
                } else {
                    annotations[annotationText] = ""
                }
            }

            return annotations
        } else {
            return [:]
        }
    }

    private func findProperties(structure:[String:AnyObject], docs:[String:AnyObject]) throws -> [GeneratedProperty] {
        var result:[GeneratedProperty] = []

        if let substructure = structure[SwiftDocKey.Substructure.rawValue] as? [[String:AnyObject]],
                let subdocs = docs[SwiftDocKey.Substructure.rawValue] as? [[String:AnyObject]]{
            for (property, docProperty) in zip(substructure, subdocs) {
                if var type = property[SwiftDocKey.TypeName.rawValue] as? String,
                        let name = property[SwiftDocKey.Name.rawValue] as? String,
                        let kind = property[SwiftDocKey.Kind.rawValue] as? String
                        where kind == SwiftDeclarationKind.VarInstance.rawValue {
                    type = type.stringByReplacingOccurrencesOfString(" ", withString:"")

                    var generic = ""
                    if type.hasPrefix("[") {
                        if type.containsString(":") {
                            if type.hasPrefix("[String:") {
                                generic = type
                                .stringByReplacingOccurrencesOfString("[String:", withString: "")
                                .stringByReplacingOccurrencesOfString("]", withString: "")
                                type = "[:]"
                            } else if type.hasPrefix("[NSString:") {
                                    generic = type
                                    .stringByReplacingOccurrencesOfString("[NSString:", withString: "")
                                    .stringByReplacingOccurrencesOfString("]", withString: "")
                                    type = "[:]"
                            } else {
                                throw KTVGeneratorError.DictionariesCantHaveKeysOtherThanStrings
                            }
                        } else {
                            generic = type
                            .stringByReplacingOccurrencesOfString("[", withString: "")
                            .stringByReplacingOccurrencesOfString("]", withString: "")
                            type = "[]"
                        }
                    }

                    if name == type {
                        throw KTVGeneratorError.TypesDefinitionsAreMandatory
                    }

                    let generatedProperty = GeneratedProperty(name: name, type: type, genericType: generic, attributes:extractAnnotations(docProperty))

                    let accessibility = property["key.accessibility"] as? String
                    let setterAccessibility = property["key.setter_accessibility"] as? String
                    if accessibility == "source.lang.swift.accessibility.internal" ||
                       accessibility == "source.lang.swift.accessibility.public" {
                        // бывает еще source.lang.swift.accessibility.private
                        if setterAccessibility != nil && setterAccessibility != "source.lang.swift.accessibility.private" {
                            // we use for serialization only public/internal properties
                            result.append(generatedProperty)
                        }
                    }
                }
            }
        }

        return result
    }

    private func findFilesThatNeedGeneration() throws -> [String] {
        let fileManager = NSFileManager.defaultManager()

        if !fileManager.fileExistsAtPath(_rootPathToSearchForClasses) {
            throw KTVGeneratorError.CantFindPathWhereToSearchClasses
        }

        var filesWithClasses:[String] = []

        if let enumerator = fileManager.enumeratorAtPath(_rootPathToSearchForClasses) {
            while let element = enumerator.nextObject() as? String {
                if element.hasSuffix(".swift") {
                    filesWithClasses.append("\(_rootPathToSearchForClasses)/\(element)")
                }
            }
        }

        filesWithClasses = try filesWithClasses.filter { swiftFileName in
            let sourceCode = try String(contentsOfFile:swiftFileName)
            //ToDo: throw an error, if ": KTVModelObject" is mentioned but no class/struct. Or ObjC mentioned without @objc or something else

            let classRegExp = "(@objc)?[\\s\\n\\r]*class[\\s\\n\\r]*[^\\s]+[\\s\\n\\r]*:[\\s\\n\\r]*(NSObject\\,)?[\\s\\n\\r]*KTVModelObject"
            let structRegExp = "struct[\\s\\n\\r]*[^\\s]+[\\s\\n\\r]*:[\\s\\n\\r]*KTVModelObject"

            let classRange = sourceCode.rangeOfString(classRegExp, options:[.RegularExpressionSearch], range:Range(sourceCode.startIndex..<sourceCode.endIndex))
            let structRange = sourceCode.rangeOfString(structRegExp, options:[.RegularExpressionSearch], range:Range(sourceCode.startIndex..<sourceCode.endIndex))

            if let _ = classRange {
                return true
            } else if let _ = structRange {
                return true
            }

            return false
        }

        return filesWithClasses
    }
}
